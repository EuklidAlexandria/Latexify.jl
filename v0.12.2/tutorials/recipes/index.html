<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Recipes · Latexify.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Latexify.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Latexify.jl</a></li><li class="current"><a class="toctext" href>Recipes</a><ul class="internal"></ul></li><li><span class="toctext">Use with other packages</span><ul><li><a class="toctext" href="../parameterizedfunctions/">Use with ParameterizedFunctions</a></li><li><a class="toctext" href="../DiffEqBiological/">Use with @reaction_network from DiffEqBiological.jl.</a></li></ul></li><li><a class="toctext" href="../../arguments/">List of possible arguments</a></li><li><a class="toctext" href="../inner_workings/">Inner workings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Recipes</a></li></ul><a class="edit-page" href="https://github.com/korsbo/Latexify.jl/blob/master/docs/src/tutorials/recipes.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Recipes</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Recipes-1" href="#Recipes-1">Recipes</a></h1><p>Recipes provides a concise means of extending Latexify.jl to work with types of your own making or of other packages. The <code>@latexrecipe</code> macro allows you to specify how a an argument type (or a set of types) should be pre-processed before they are passed to the standard <code>latexify</code> function. Also, it allows you to define both new keyword arguments as well as to set the defaults of pre-existing ones. The main power of this macro is that is defines the necessary functions <em>within</em> Latexify.jl itself, as opposed to within the module where it is called. </p><p>The recipe syntax closely follow that of the <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a> <a href="https://github.com/JuliaPlots/RecipesBase.jl">recipes</a> and, indeed, most of the code is copied and adapted from them (cred to the authors!). </p><p>So. The easiest way to explain it is by showing an example where we define a recipe for our type <code>MyType</code>. </p><pre><code class="language-julia">using Latexify

struct MyType 
   vector::Vector
end</code></pre><pre><code class="language-julia">@latexrecipe function f(x::MyType; reverse=false)
    ## we can access the input object and perform operations like in a normal function.
    vec = x.vector
    if reverse
        vec = vec[end:-1:1]
    end

    ## we can define defult keyword arguments to be passed along to latexify 
    ## using an arrow notation, --&gt; 
    env --&gt; :array
    transpose --&gt; true
    ## These can be overridden by the keyword arguments passed to the latexify function.

    ## If you use the := operator to specify a value it cannot be overridden.
    fmt := &quot;%.2f&quot;

    ## The return value should be something that latexify already knows how to work with.
    ## In this case, we have a simple vector which is fine!
    return vec
end</code></pre><pre><code class="language-julia">mytype = MyType([1, 2, 3])

latexify(mytype; reverse=true)</code></pre><div>\[\begin{equation}
\left[
\begin{array}{c}
3.00 \\
2.00 \\
1.00 \\
\end{array}
\right]
\end{equation}\]</div><p>The required signature of the macro is</p><pre><code class="language-julia">@latexrecipe function f(x::MyType, ...; ...)
    return something
end</code></pre><p>Here, the function name is unimportant, but the type signature is key.  There must also be a return statement which returns something that base Latexify already works with (Arrays, Tuples, Numbers, Symbols, Strings, etc.) The special notation <code>kwarg --&gt; value</code> resets the default value of a keyword argument for your specific inputs. This will be overridden if the keyword argument in quesion is specified in a call to <code>latexify</code>.  To disallow this overriding, use <code>kwarg := value</code> instead.</p><p>The use of <code>@latexrecipe</code> to redefine how an already supported type should be interpreted is highly discouraged. There is (currently) nothing in place to forbid this but it could mess up how latexify works with other packages. Disregarding this in your own sessions is one thing, but doing it in a package could cause very difficult issues for the users of your package. </p><p>If a recipe is defined within a module, everything should just work without the need to export anything. </p><footer><hr/><a class="previous" href="../../"><span class="direction">Previous</span><span class="title">Latexify.jl</span></a><a class="next" href="../parameterizedfunctions/"><span class="direction">Next</span><span class="title">Use with ParameterizedFunctions</span></a></footer></article></body></html>
